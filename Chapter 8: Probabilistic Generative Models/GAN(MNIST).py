#Reference: https://realpython.com/generative-adversarial-networks/

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import torch
from torch import nn
import math
import torchvision
import torchvision.transforms as transforms
import os
import certifi
os.environ['SSL_CERT_FILE'] = certifi.where()

torch.manual_seed(42)

#Preparing training data
#Explanation to be read in reference above
transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,))])

#Load the training set
train_set = torchvision.datasets.MNIST(root='./MNIST_Data', train=True, transform=transform, download=True)

#Create dataloader
batch_size = 32
train_loader = torch.utils.data.DataLoader(train_set, batch_size=batch_size, shuffle=True)

real_samples, mnist_labels = next(iter(train_loader))
for i in range(16):
    ax = plt.subplot(4, 4, i + 1)
    plt.imshow(real_samples[i].numpy().reshape(28, 28), cmap='gray_r')
    plt.xticks([])
    plt.yticks([])
plt.show()

#Implement the Discriminator
#Input: 28 pixels * 28 pixels = 784
class Discriminator(nn.Module):
    def __init__(self):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(784, 1024),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(1024, 512),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(512, 256),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(256, 1),
            nn.Sigmoid(),
        )
    def forward(self, x):
        x = x.view(x.size(0), 784)
        output = self.model(x)
        return output

discriminator = Discriminator()

#Implement the Generator
class Generator(nn.Module):
    def __init__(self):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(100, 256),
            nn.ReLU(),
            nn.Linear(256, 512),
            nn.ReLU(),
            nn.Linear(512, 1024),
            nn.ReLU(),
            nn.Linear(1024, 2048),
            nn.ReLU(),
            nn.Linear(2048, 784),
            nn.Tanh(),
        )
    def forward(self, x):
        output = self.model(x)
        output = output.view(output.size(0), 1, 28, 28)
        return output

generator = Generator()

#Training the models
lr = 0.0001
epochs = 50
loss_function = nn.BCELoss()
optimizer_discriminator = torch.optim.Adam(discriminator.parameters(), lr=lr)
optimizer_generator = torch.optim.Adam(generator.parameters(), lr=lr)

for epoch in range(epochs):
    for n, (real_samples, mnist_labels) in enumerate(train_loader):
        #Data for training the discriminator
        real_samples_labels = torch.ones((batch_size, 1))
        latent_space_samples = torch.randn((batch_size, 100))
        generated_samples = generator(latent_space_samples)
        generated_samples_labels = torch.zeros((batch_size, 1))
        all_samples = torch.cat((real_samples, generated_samples))
        all_samples_labels = torch.cat((real_samples_labels, generated_samples_labels))

        #Training the discriminator
        discriminator.zero_grad()
        output_discriminator = discriminator(all_samples)
        loss_discriminator = loss_function(output_discriminator, all_samples_labels)
        loss_discriminator.backward()
        optimizer_discriminator.step()

        #Data for training the generator
        latent_space_samples = torch.randn((batch_size, 100))

        #Training the generator
        generator.zero_grad()
        generated_samples = generator(latent_space_samples)
        output_discriminator_generated = discriminator(generated_samples)
        loss_generator = loss_function(output_discriminator_generated, real_samples_labels)
        loss_generator.backward()
        optimizer_generator.step()

        #Show loss
        if n==batch_size-1:
            print(f'Epoch: {epoch}, Loss D.: {loss_discriminator}')
            print(f'Epoch: {epoch}, Loss G.: {loss_generator}')


#Checking samples generated by GAN
latent_space_samples = torch.randn((batch_size, 100))
generated_samples = generator(latent_space_samples)
generated_samples = generated_samples.detach()
for i in range(16):
    ax = plt.subplot(4, 4, i + 1)
    plt.imshow(generated_samples[i].reshape(28, 28), cmap='gray_r')
    plt.xticks([])
    plt.yticks([])
plt.show()

#Currently doesnt converge
##What if i remove one hidden layer from discriminator? or add more layers to the generator?
#Edited, adding layers to generator does help the loss